## Context

`technical_daily` 表已通过 database-schema spec 定义并由 Alembic 迁移创建，包含 MA(5/10/20/60/120/250)、MACD(DIF/DEA/HIST)、KDJ(K/D/J)、RSI(6/12/24)、BOLL(上/中/下轨)、成交量均线(vol_ma5/vol_ma10)、量比(vol_ratio)、ATR14 共 23 个指标列。

当前状态：表结构存在但无数据填充逻辑。`DataManager` 已实现 `get_daily_bars()` 可查询 `stock_daily` 原始日线数据，但没有技术指标计算和写入能力。

策略引擎的 Layer 2（技术指标初筛）直接依赖 `technical_daily` 表的预计算数据做向量化批量筛选，因此本模块是数据采集与策略引擎之间的关键桥梁。

## Goals / Non-Goals

**Goals:**
- 实现所有 23 个技术指标的向量化计算（纯 pandas，不引入 TA-Lib 等 C 扩展依赖）
- 支持单股票计算（返回 DataFrame）和全市场批量计算（遍历写入 DB）
- 支持增量计算：每日收盘后仅计算最新交易日的指标
- 提供 CLI 命令供手动触发和定时任务调度调用
- 在 DataManager 中新增查询接口供策略引擎消费

**Non-Goals:**
- 不引入 TA-Lib / ta / pandas-ta 等第三方技术分析库（V1 用 pandas 手写，减少安装依赖）
- 不做 Redis 缓存写入（V1 策略引擎直接查 PostgreSQL，Redis 缓存留给后续优化）
- 不做实时计算（仅盘后批处理）
- 不新增或修改 `technical_daily` 表结构（使用现有 DDL）

## Decisions

### Decision 1: 纯 pandas 实现 vs 引入 TA-Lib

**选择：纯 pandas 实现**

- **TA-Lib 优势：** 计算速度快（C 底层），API 成熟，覆盖 200+ 指标
- **TA-Lib 劣势：** 需要编译安装 C 库（macOS/Linux 安装步骤不同），增加部署复杂度
- **pandas 优势：** 零额外依赖，代码透明可调试，V1 只需 23 个指标完全可控
- **pandas 劣势：** 性能略低，但单股票 250 天数据的计算在毫秒级，全市场 5000 只串行也在分钟级
- **结论：** V1 单机场景下性能不是瓶颈，优先降低部署复杂度。V2 如需优化可替换为 TA-Lib

### Decision 2: 计算架构 — 逐股串行 vs 全市场宽表

**选择：逐股串行计算**

- **全市场宽表方案：** 一次性加载所有股票的日线数据到一个大 DataFrame，用 groupby 计算。内存占用大（5000 股 × 300 天 ≈ 1.5M 行），但代码简洁
- **逐股串行方案：** 遍历每只股票，加载其历史日线，计算指标，写入 DB。内存占用小（每次仅一只股票的数据），但需要循环
- **结论：** 逐股串行更稳健。单股计算约 5-10ms，5000 只约 25-50 秒，完全可接受。内存峰值可控在 100MB 以内。全量计算时使用批量 INSERT 提升写入效率

### Decision 3: 增量计算策略

**选择：基于最新交易日的增量计算**

- 增量模式：查询 `stock_daily` 中最新交易日的所有股票，对每只股票加载足够的历史窗口（250 天，满足 MA250 需求），计算当日指标，UPSERT 到 `technical_daily`
- 全量模式：对每只股票的全部历史日线数据计算指标，TRUNCATE + INSERT 或逐日 UPSERT
- 增量模式是每日定时任务的主要调用方式，全量模式仅在初始化或数据修复时使用

### Decision 4: 指标计算的历史窗口需求

各指标所需的最小历史数据量：

| 指标 | 最小窗口 | 说明 |
|:---|:---|:---|
| MA250 | 250 天 | 年线，需要最长窗口 |
| MA120 | 120 天 | 半年线 |
| MACD(12,26,9) | 35 天 | 26 + 9 天 EMA 收敛 |
| KDJ(9,3,3) | 12 天 | 9 天窗口 + 平滑 |
| RSI(24) | 25 天 | 24 天周期 + 1 |
| BOLL(20,2) | 20 天 | 20 天标准差 |
| ATR(14) | 15 天 | 14 天真实波幅 |
| vol_ma10 | 10 天 | 成交量 10 日均线 |

**结论：** 统一加载 300 天历史数据（覆盖 MA250 + 余量），对数据不足的新股，指标值设为 NULL

### Decision 5: 数据库写入策略

**选择：PostgreSQL UPSERT (INSERT ... ON CONFLICT DO UPDATE)**

- 使用 `ON CONFLICT (ts_code, trade_date) DO UPDATE` 实现幂等写入
- 全量计算时按股票分批提交（每 100 只股票 commit 一次），避免长事务
- 增量计算时一次性提交当日所有股票的指标数据

### Decision 6: 模块位置

**选择：放在 `app/data/indicator.py`**

- 技术指标计算本质上是数据加工（ETL 的延伸），属于数据层职责
- 与 `app/data/etl.py`（清洗）、`app/data/manager.py`（查询）同层
- CLI 命令扩展到现有的 `app/data/cli.py`

## Risks / Trade-offs

- **[性能] 全量计算耗时较长** → 全量计算预计 1-3 分钟（5000 股 × 300 天），仅在初始化时运行一次，可接受。增量计算（单日）预计 30-60 秒
- **[精度] pandas 浮点计算与 TA-Lib 结果可能有微小差异** → V1 不做跨库对比，自洽即可。计算公式参考通达信/同花顺标准算法
- **[数据不足] 新上市股票历史数据不够 250 天** → 指标值设为 NULL，策略引擎需处理 NULL 值
- **[并发安全] 增量计算与策略引擎同时读写 `technical_daily`** → PostgreSQL MVCC 保证读写不冲突，策略引擎读到的是已提交的快照
