# V4 详细设计：量价配合策略实现方案

> **版本：** v2.0（SQL + Python 混合方案）
> **日期：** 2026-02-27
> **关联：** 00-V4概要设计-量价配合策略.md

---

## 1. 设计原则

与现有 34 个策略保持一致的混合架构：

| 层级 | 职责 | 技术选型 |
|------|------|---------|
| 指标预计算 | MA、MACD、量比等 | 已有 `compute_incremental`（Python/TA-Lib 等效算法）→ 写入 `technical_daily` |
| 策略执行 | 批量筛选 + 观察池管理 | SQL 窗口函数做重计算 + Python 做状态机逻辑 |
| 数据存储 | 观察池持久化 | PostgreSQL `strategy_watchpool` 表 |

**核心思路：** 所有需要的指标（MA、量比、MACD）已经在 `technical_daily` 和 `index_technical_daily` 中预计算好了，策略执行阶段只做 SQL 查询 + 比较判断，不引入 Pandas/TA-Lib 运行时计算。

---

## 2. 策略参数定义

所有参数可通过 `strategies` 表的 `params` JSONB 字段覆盖。

```python
DEFAULT_PARAMS = {
    # === 第一阶段：吸筹识别 ===
    "accumulation_days": 60,          # 吸筹观察窗口（交易日，约3个月，覆盖主力吸筹周期）
    "max_accumulation_range": 0.20,   # 窄幅震荡最大振幅 20%（时间拉长允许稍大波动）

    # === 第二阶段：T0 放量突破 ===
    "min_t0_pct_chg": 6.0,           # T0 最小涨幅 6%
    "min_t0_vol_ratio": 2.5,         # T0 成交量 >= 20日均量的 2.5 倍

    # === 第三阶段：缩量回踩 ===
    "min_washout_days": 3,            # 最少回踩天数
    "max_washout_days": 8,            # 最多回踩天数（超过则过期）
    "max_vol_shrink_ratio": 0.40,     # Tk 成交量 <= T0 成交量的 40%
    "price_floor": "t0_open",         # 价格底线：t0_open 或 t0_mid

    # === 第四阶段：企稳触发 ===
    "max_tk_amplitude": 3.0,          # Tk 日振幅 <= 3%
    "ma_support_tolerance": 0.015,    # 均线支撑容差 1.5%
    "support_ma_periods": [10, 20],   # 支撑均线周期

    # === 大盘环境 ===
    "market_index": "000300.SH",      # 参考指数（沪深300）
    "market_filter_enabled": True,

    # === 行业共振 ===
    "sector_filter_enabled": True,
    "sector_top_pct": 0.20,           # 只在排名前 20% 的板块中选股
    "sector_momentum_days": 5,

    # === 观察池管理 ===
    "watchpool_max_size": 200,
    "watchpool_expire_days": 12,
}
```

---

## 3. 数据库表设计

### 3.1 观察池表

```sql
CREATE TABLE strategy_watchpool (
    id SERIAL PRIMARY KEY,
    ts_code VARCHAR(16) NOT NULL,
    strategy_name VARCHAR(64) NOT NULL DEFAULT 'volume-price-pattern',
    t0_date DATE NOT NULL,
    t0_close NUMERIC(20,4),
    t0_open NUMERIC(20,4),
    t0_low NUMERIC(20,4),
    t0_volume BIGINT,
    t0_pct_chg NUMERIC(10,4),
    status VARCHAR(16) NOT NULL DEFAULT 'watching',
    washout_days INT DEFAULT 0,
    min_washout_vol BIGINT,
    min_washout_low NUMERIC(20,4),
    sector_score NUMERIC(10,4),
    market_score NUMERIC(10,4),
    triggered_date DATE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(ts_code, t0_date, strategy_name)
);

CREATE INDEX idx_watchpool_status ON strategy_watchpool(status);
CREATE INDEX idx_watchpool_date ON strategy_watchpool(t0_date);
```

### 3.2 状态流转

```
[新 T0 检测] → watching → triggered（企稳触发，输出选股）
                       → expired（超过 max_washout_days 未触发）
                       → stopped（价格跌破 T0 底线）
```

---

## 4. 四阶段实现（SQL + Python 混合）

### 4.1 阶段一：吸筹识别（SQL 窗口函数）

T0 发生时，回查前 N 日振幅。使用 SQL 一次性计算：

```sql
-- 检查 T0 前 accumulation_days 天的振幅是否 < max_accumulation_range
WITH hist AS (
    SELECT ts_code,
           MAX(high) AS high_max,
           MIN(low)  AS low_min
    FROM stock_daily
    WHERE trade_date BETWEEN :start_date AND :t0_prev_date
      AND ts_code = :code
    GROUP BY ts_code
)
SELECT ts_code,
       (high_max - low_min) / NULLIF(low_min, 0) AS amplitude
FROM hist
WHERE (high_max - low_min) / NULLIF(low_min, 0) <= :max_range
```

实际实现中，对所有候选 T0 股票批量执行：

```sql
-- 批量检查所有候选 T0 的吸筹条件
WITH candidates AS (
    -- 当日满足 T0 放量突破条件的股票（见 4.2）
    SELECT ts_code FROM t0_candidates
),
accumulation_check AS (
    SELECT sd.ts_code,
           MAX(sd.high) AS high_max,
           MIN(sd.low)  AS low_min
    FROM stock_daily sd
    JOIN candidates c ON sd.ts_code = c.ts_code
    WHERE sd.trade_date BETWEEN :start_date AND :prev_date
    GROUP BY sd.ts_code
)
SELECT ts_code
FROM accumulation_check
WHERE (high_max - low_min) / NULLIF(low_min, 0) <= :max_range
```

### 4.2 阶段二：T0 放量突破检测（Pipeline DataFrame 列判断）

直接使用 `filter_batch` 传入的 DataFrame 中已有的列：

```python
def _detect_t0_breakout(self, df: pd.DataFrame) -> pd.Series:
    """检测当日 T0 放量突破。

    使用 Pipeline 已提供的列（来自 stock_daily + technical_daily）：
    - pct_chg: 当日涨幅（stock_daily）
    - vol_ratio: 量比 = 当日量 / 20日均量（technical_daily 预计算）
    - vol: 成交量（stock_daily）
    """
    min_chg = self.params["min_t0_pct_chg"]
    min_vol = self.params["min_t0_vol_ratio"]

    pct_chg = df.get("pct_chg", pd.Series(dtype=float)).fillna(0)
    vol_ratio = df.get("vol_ratio", pd.Series(dtype=float)).fillna(0)
    trading = df.get("vol", pd.Series(dtype=float)).fillna(0) > 0

    return (pct_chg >= min_chg) & (vol_ratio >= min_vol) & trading
```

### 4.3 阶段三：观察池状态更新（SQL 批量操作）

每日盘后对观察池中 `watching` 状态的记录进行批量更新：

```sql
-- Step 1: 批量获取观察池股票的当日行情
WITH pool AS (
    SELECT w.id, w.ts_code, w.t0_open, w.t0_low, w.t0_volume,
           w.washout_days, w.min_washout_vol, w.min_washout_low
    FROM strategy_watchpool w
    WHERE w.status = 'watching'
),
today_data AS (
    SELECT sd.ts_code, sd.close, sd.low, sd.high, sd.vol
    FROM stock_daily sd
    WHERE sd.trade_date = :target_date
      AND sd.ts_code IN (SELECT ts_code FROM pool)
)
SELECT p.id, p.ts_code, p.t0_open, p.t0_volume, p.washout_days,
       p.min_washout_vol, p.min_washout_low,
       t.close, t.low, t.high, t.vol AS today_vol
FROM pool p
JOIN today_data t ON p.ts_code = t.ts_code
```

Python 层做状态判断后，批量 UPDATE：

```python
async def _update_watchpool(self, session, target_date: date):
    """批量更新观察池状态。"""
    # 1. 一次 SQL 查询拿到所有 watching 记录 + 当日行情
    rows = await session.execute(text(WATCHPOOL_UPDATE_SQL), {"target_date": target_date})
    items = rows.fetchall()

    stopped_ids = []
    expired_ids = []
    update_batch = []  # (id, washout_days, min_vol, min_low)

    for item in items:
        # 价格跌破 T0 底线 → stopped
        if item.low < float(item.t0_open):
            stopped_ids.append(item.id)
            continue

        new_days = item.washout_days + 1

        # 超过最大回踩天数 → expired
        if new_days > self.params["max_washout_days"]:
            expired_ids.append(item.id)
            continue

        # 更新缩量和最低价
        min_vol = min(item.today_vol, item.min_washout_vol or item.today_vol)
        min_low = min(float(item.low), float(item.min_washout_low or item.low))
        update_batch.append((item.id, new_days, min_vol, min_low))

    # 2. 批量 UPDATE（三条 SQL 搞定）
    if stopped_ids:
        await session.execute(text(
            "UPDATE strategy_watchpool SET status='stopped', updated_at=:d "
            "WHERE id = ANY(:ids)"
        ), {"ids": stopped_ids, "d": target_date})

    if expired_ids:
        await session.execute(text(
            "UPDATE strategy_watchpool SET status='expired', updated_at=:d "
            "WHERE id = ANY(:ids)"
        ), {"ids": expired_ids, "d": target_date})

    if update_batch:
        # 使用 VALUES 批量更新
        await session.execute(text("""
            UPDATE strategy_watchpool AS w SET
                washout_days = v.days,
                min_washout_vol = v.min_vol,
                min_washout_low = v.min_low,
                updated_at = :d
            FROM (VALUES %s) AS v(id, days, min_vol, min_low)
            WHERE w.id = v.id
        """ % ",".join(f"({i},{d},{v},{l})" for i,d,v,l in update_batch)),
        {"d": target_date})

    await session.commit()
```

### 4.4 阶段四：Tk 企稳信号检测（SQL + Python）

```sql
-- 从观察池中找出满足企稳条件的股票
WITH pool AS (
    SELECT w.id, w.ts_code, w.t0_volume, w.t0_open, w.washout_days
    FROM strategy_watchpool w
    WHERE w.status = 'watching'
      AND w.washout_days >= :min_days
),
today AS (
    SELECT sd.ts_code, sd.close, sd.open, sd.high, sd.low, sd.vol,
           td.ma10, td.ma20
    FROM stock_daily sd
    JOIN technical_daily td ON sd.ts_code = td.ts_code AND sd.trade_date = td.trade_date
    WHERE sd.trade_date = :target_date
      AND sd.ts_code IN (SELECT ts_code FROM pool)
)
SELECT p.id, p.ts_code, p.t0_volume, p.t0_open,
       t.close, t.open, t.high, t.low, t.vol AS today_vol,
       t.ma10, t.ma20,
       -- 振幅
       CASE WHEN t.close > 0
            THEN (t.high - t.low) / t.close * 100
            ELSE 999 END AS amplitude,
       -- 量比（相对 T0）
       CASE WHEN p.t0_volume > 0
            THEN t.vol::float / p.t0_volume
            ELSE 999 END AS vol_shrink_ratio,
       -- MA10 距离
       CASE WHEN t.ma10 > 0
            THEN ABS(t.low / t.ma10 - 1)
            ELSE 999 END AS ma10_distance,
       -- MA20 距离
       CASE WHEN t.ma20 > 0
            THEN ABS(t.low / t.ma20 - 1)
            ELSE 999 END AS ma20_distance
FROM pool p
JOIN today t ON p.ts_code = t.ts_code
WHERE t.close > p.t0_open                                    -- 价格在 T0 开盘价之上
  AND (t.high - t.low) / NULLIF(t.close, 0) * 100 <= :max_amp  -- 振幅 <= 3%
  AND t.vol::float / NULLIF(p.t0_volume, 0) <= :max_vol_ratio  -- 缩量 <= 40%
  AND (
      ABS(t.low / NULLIF(t.ma10, 0) - 1) <= :ma_tolerance      -- 触及 MA10
      OR ABS(t.low / NULLIF(t.ma20, 0) - 1) <= :ma_tolerance   -- 或触及 MA20
  )
```

Python 层只需处理结果：

```python
async def _check_stabilization(self, session, target_date: date) -> list[str]:
    """检测企稳信号，返回触发的 ts_code 列表。"""
    rows = await session.execute(text(STABILIZATION_SQL), {
        "target_date": target_date,
        "min_days": self.params["min_washout_days"],
        "max_amp": self.params["max_tk_amplitude"],
        "max_vol_ratio": self.params["max_vol_shrink_ratio"],
        "ma_tolerance": self.params["ma_support_tolerance"],
    })
    triggered = rows.fetchall()

    triggered_codes = []
    triggered_ids = []
    for row in triggered:
        triggered_codes.append(row.ts_code)
        triggered_ids.append(row.id)

    # 批量更新状态为 triggered
    if triggered_ids:
        await session.execute(text(
            "UPDATE strategy_watchpool SET status='triggered', "
            "triggered_date=:d, updated_at=:d WHERE id = ANY(:ids)"
        ), {"ids": triggered_ids, "d": target_date})
        await session.commit()

    return triggered_codes
```

---

## 5. 大盘环境过滤器（SQL 查询）

直接查询已有的 `index_technical_daily` 表，无需额外计算：

```python
class MarketFilter:
    """大盘环境过滤器 — 基于 index_technical_daily 预计算指标。"""

    class MarketState(str, Enum):
        BULLISH = "bullish"    # 全力执行，权重 1.0
        NEUTRAL = "neutral"    # 降权执行，权重 0.5
        BEARISH = "bearish"    # 策略熔断，权重 0.0

    EVALUATE_SQL = """
        SELECT id.close, itd.ma20, itd.ma60, itd.macd
        FROM index_daily id
        JOIN index_technical_daily itd
          ON id.ts_code = itd.ts_code AND id.trade_date = itd.trade_date
        WHERE id.ts_code = :index_code AND id.trade_date = :target_date
    """

    async def evaluate(self, session, target_date: date, index_code: str) -> MarketState:
        row = await session.execute(text(self.EVALUATE_SQL), {
            "index_code": index_code, "target_date": target_date
        })
        data = row.fetchone()
        if not data:
            return self.MarketState.NEUTRAL

        close, ma20, ma60, macd = float(data.close), float(data.ma20 or 0), \
                                   float(data.ma60 or 0), float(data.macd or 0)

        if ma20 > 0 and close > ma20 and macd > 0:
            return self.MarketState.BULLISH
        elif ma60 > 0 and close > ma60:
            return self.MarketState.NEUTRAL
        else:
            return self.MarketState.BEARISH
```

---

## 6. 行业板块共振过滤器（SQL 查询）

利用已有的 `concept_daily` 表计算板块动量排名：

```python
class SectorFilter:
    """行业板块共振过滤器 — 基于 concept_daily 预计算数据。"""

    STRONG_SECTORS_SQL = """
        WITH sector_perf AS (
            SELECT ts_code, SUM(pct_chg) AS total_chg
            FROM concept_daily
            WHERE trade_date BETWEEN :start_date AND :end_date
            GROUP BY ts_code
        ),
        ranked AS (
            SELECT ts_code, total_chg,
                   PERCENT_RANK() OVER (ORDER BY total_chg DESC) AS pct_rank
            FROM sector_perf
        )
        SELECT ts_code FROM ranked WHERE pct_rank <= :top_pct
    """

    async def get_strong_sectors(self, session, target_date, top_pct, days) -> set[str]:
        """获取排名前 top_pct 的强势板块代码集合。"""
        # 计算起始日期（近 N 个交易日）
        start = await self._get_trade_date_offset(session, target_date, days)
        rows = await session.execute(text(self.STRONG_SECTORS_SQL), {
            "start_date": start, "end_date": target_date, "top_pct": top_pct
        })
        return {r.ts_code for r in rows}
```

---

## 7. 策略主体实现

### 7.1 类定义与 Pipeline 集成

```python
class VolumePricePatternStrategy(BaseStrategy):
    """量价配合策略：放量突破 + 缩量回踩。

    与现有策略的关键区别：需要通过观察池做多日状态追踪。
    在 filter_batch 内部通过 async_session_factory 获取数据库连接。
    """

    name = "volume-price-pattern"
    display_name = "量价配合（龙回头）"
    category = "technical"
    description = "放量突破后缩量回踩企稳，捕捉主升浪启动点"
    default_params = DEFAULT_PARAMS

    async def filter_batch(
        self, df: pd.DataFrame, target_date: date
    ) -> pd.Series:
        """Pipeline 标准接口。

        执行流程：
        1. 大盘环境检查（SQL 查 index_technical_daily）
        2. 扫描新 T0（DataFrame 列判断）→ 吸筹验证（SQL）→ 写入观察池
        3. 更新观察池状态（SQL 批量）
        4. 检测 Tk 企稳（SQL 查询）→ 返回选股结果
        """
        from app.database import async_session_factory

        result = pd.Series(False, index=df.index)

        async with async_session_factory() as session:
            # Step 1: 大盘环境
            if self.params["market_filter_enabled"]:
                market_state = await MarketFilter().evaluate(
                    session, target_date, self.params["market_index"]
                )
                if market_state == MarketFilter.MarketState.BEARISH:
                    logger.info("[volume-price-pattern] 大盘熔断，跳过")
                    return result

            # Step 2: 扫描新 T0 事件
            t0_mask = self._detect_t0_breakout(df)
            if t0_mask.any():
                t0_codes = df.loc[t0_mask, ["ts_code", "close", "open",
                                             "low", "vol", "pct_chg"]]
                # SQL 批量验证吸筹条件 + 写入观察池
                await self._process_new_t0(session, t0_codes, target_date)

            # Step 3: 更新观察池（SQL 批量）
            await self._update_watchpool(session, target_date)

            # Step 4: 检测 Tk 企稳（SQL 查询）
            triggered_codes = await self._check_stabilization(session, target_date)

            # Step 5: 行业共振加分（可选）
            if self.params["sector_filter_enabled"] and triggered_codes:
                strong_sectors = await SectorFilter().get_strong_sectors(
                    session, target_date,
                    self.params["sector_top_pct"],
                    self.params["sector_momentum_days"],
                )
                # 不过滤，但记录板块得分供加权排序使用
                await self._update_sector_scores(
                    session, triggered_codes, strong_sectors, target_date
                )

        if triggered_codes:
            result = df["ts_code"].isin(triggered_codes)

        return result
```

### 7.2 数据依赖总结

| 数据 | 来源表 | 阶段 | 说明 |
|------|--------|------|------|
| pct_chg, vol, open, close, high, low | stock_daily → Pipeline df | T0 检测 | 已在 DataFrame 中 |
| vol_ratio | technical_daily → Pipeline df | T0 检测 | 已预计算 |
| ma10, ma20 | technical_daily | Tk 企稳 | SQL 查询 |
| 前 20 日 high/low | stock_daily | 吸筹验证 | SQL 窗口函数 |
| 指数 close, ma20, ma60, macd | index_daily + index_technical_daily | 大盘过滤 | SQL 查询 |
| 板块 pct_chg | concept_daily | 行业共振 | SQL 聚合 |

**所有数据源均为现有表，无需新增数据采集。**

---

## 8. 性能预估

| 操作 | 预估耗时 | 说明 |
|------|---------|------|
| T0 检测 | <10ms | DataFrame 向量化比较 |
| 吸筹验证 | <50ms | SQL 批量查询（通常 <20 只候选） |
| 观察池更新 | <30ms | SQL 批量 UPDATE（池内 <200 只） |
| Tk 企稳检测 | <20ms | SQL JOIN 查询 |
| 大盘环境 | <5ms | 单行 SQL 查询 |
| 行业共振 | <30ms | SQL 聚合 |
| **总计** | **<150ms** | 远低于现有策略的 1s 总预算 |
