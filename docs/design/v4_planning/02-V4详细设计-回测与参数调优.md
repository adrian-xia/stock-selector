# V4 详细设计：回测与参数调优

> **版本：** v1.0
> **日期：** 2026-02-27
> **关联：** 00-V4概要设计-量价配合策略.md、01-V4详细设计-量价配合策略.md

---

## 1. 设计目标

在策略上线前，通过历史数据验证量价配合策略的有效性，并通过参数网格搜索找到最优参数组合。

| 目标 | 说明 |
|------|------|
| 策略验证 | 确认"放量突破 + 缩量回踩"形态在历史数据中具有统计显著性 |
| 参数调优 | 找到胜率、盈亏比最优的参数组合 |
| 风险评估 | 量化最大回撤、夏普比率等风险指标 |
| 持续优化 | 支持定期重跑，随市场环境变化动态调整参数 |

---

## 2. 回测引擎设计

### 2.1 整体架构

```
回测引擎
├── 数据层：从 stock_daily + technical_daily 取历史数据
├── 模拟层：按日期逐日模拟 Pipeline 执行
│   ├── 大盘环境检查（index_daily + index_technical_daily）
│   ├── 行业共振检查（concept_daily）
│   ├── T0 识别 → 写入模拟观察池
│   ├── 观察池状态更新（回踩/过期/止损）
│   └── Tk 企稳触发 → 记录买入信号
├── 收益计算层：对每个买入信号计算 1d/3d/5d/10d 实际收益
└── 评估层：胜率、盈亏比、夏普比率、最大回撤等
```

### 2.2 数据来源

与策略执行完全一致，复用现有表，无需额外数据采集：

| 数据 | 来源表 | 用途 |
|------|--------|------|
| 个股日行情 | `stock_daily` | T0 识别、回踩追踪、收益计算 |
| 个股技术指标 | `technical_daily` | vol_ratio、MA10/20、MACD |
| 指数日行情 | `index_daily` | 大盘环境 |
| 指数技术指标 | `index_technical_daily` | 大盘 MA20/60、MACD |
| 板块日行情 | `concept_daily` | 行业共振 |

### 2.3 模拟观察池

回测时使用内存中的模拟观察池（Python dict），不写入数据库，避免污染生产数据：

```python
@dataclass
class WatchpoolEntry:
    ts_code: str
    t0_date: date
    t0_close: float
    t0_open: float
    t0_low: float
    t0_volume: int
    t0_pct_chg: float
    washout_days: int = 0
    min_washout_vol: int = 0
    min_washout_low: float = 0.0
    status: str = "watching"   # watching / triggered / expired / stopped
    triggered_date: date = None
```

### 2.4 逐日模拟流程

```python
async def run_backtest(
    session,
    params: dict,
    start_date: date,
    end_date: date,
) -> list[BacktestSignal]:
    """
    按日期逐日模拟 Pipeline 执行，返回所有触发的买入信号。
    """
    trade_dates = await _get_trade_dates(session, start_date, end_date)
    watchpool: dict[str, WatchpoolEntry] = {}
    signals: list[BacktestSignal] = []

    for target_date in trade_dates:
        # 1. 大盘环境检查
        market_state = await _check_market(session, target_date, params)
        if market_state == "bearish":
            continue

        # 2. 拉取当日全市场行情（SQL 批量）
        daily_data = await _fetch_daily_data(session, target_date)

        # 3. 扫描新 T0
        t0_candidates = _detect_t0(daily_data, params)
        for code in t0_candidates:
            if code not in watchpool:
                ok = await _verify_accumulation(session, code, target_date, params)
                if ok:
                    watchpool[code] = _make_entry(code, daily_data[code], target_date)

        # 4. 更新观察池状态
        to_remove = []
        for code, entry in watchpool.items():
            if entry.status != "watching":
                continue
            today = daily_data.get(code)
            if not today:
                continue
            _update_entry(entry, today, params)
            if entry.status != "watching":
                to_remove.append(code)

        # 5. 检测 Tk 企稳
        for code, entry in watchpool.items():
            if entry.status != "watching":
                continue
            today = daily_data.get(code)
            if not today:
                continue
            if _check_stabilization(entry, today, params):
                entry.status = "triggered"
                entry.triggered_date = target_date
                signals.append(BacktestSignal(
                    ts_code=code,
                    signal_date=target_date,
                    t0_date=entry.t0_date,
                    entry_price=today["close"],
                    market_state=market_state,
                ))

        # 清理已终结的记录
        for code in to_remove:
            del watchpool[code]

    return signals
```

### 2.5 收益计算

对每个买入信号，查询后续 1d/3d/5d/10d 的实际收益：

```sql
-- 批量查询信号后续收益
WITH signal_dates AS (
    SELECT ts_code, signal_date, entry_price
    FROM backtest_signals_temp   -- 临时表，由 Python 批量插入
),
future_prices AS (
    SELECT sd.ts_code, sd.trade_date, sd.close,
           ROW_NUMBER() OVER (
               PARTITION BY sd.ts_code, sig.signal_date
               ORDER BY sd.trade_date
           ) AS day_offset
    FROM stock_daily sd
    JOIN signal_dates sig ON sd.ts_code = sig.ts_code
    WHERE sd.trade_date > sig.signal_date
      AND sd.trade_date <= sig.signal_date + INTERVAL '20 days'
)
SELECT sig.ts_code, sig.signal_date, sig.entry_price,
       MAX(CASE WHEN fp.day_offset = 1  THEN fp.close END) AS close_1d,
       MAX(CASE WHEN fp.day_offset = 3  THEN fp.close END) AS close_3d,
       MAX(CASE WHEN fp.day_offset = 5  THEN fp.close END) AS close_5d,
       MAX(CASE WHEN fp.day_offset = 10 THEN fp.close END) AS close_10d
FROM signal_dates sig
LEFT JOIN future_prices fp ON sig.ts_code = fp.ts_code
    AND fp.day_offset IN (1, 3, 5, 10)
GROUP BY sig.ts_code, sig.signal_date, sig.entry_price
```

Python 层计算收益率：

```python
def calc_returns(row) -> dict:
    ep = row["entry_price"]
    return {
        "ret_1d":  (row["close_1d"]  / ep - 1) if row["close_1d"]  else None,
        "ret_3d":  (row["close_3d"]  / ep - 1) if row["close_3d"]  else None,
        "ret_5d":  (row["close_5d"]  / ep - 1) if row["close_5d"]  else None,
        "ret_10d": (row["close_10d"] / ep - 1) if row["close_10d"] else None,
    }
```

---

## 3. 参数网格搜索

### 3.1 参数空间定义

```python
PARAM_GRID = {
    "accumulation_days":    [30, 45, 60],
    "max_accumulation_range": [0.15, 0.18, 0.20],
    "min_t0_pct_chg":       [5.0, 6.0, 7.0],
    "min_t0_vol_ratio":     [2.0, 2.5, 3.0],
    "min_washout_days":     [2, 3, 4],
    "max_washout_days":     [6, 8, 10],
    "max_vol_shrink_ratio": [0.30, 0.40, 0.50],
    "max_tk_amplitude":     [2.0, 3.0, 4.0],
    "ma_support_tolerance": [0.010, 0.015, 0.020],
}
```

总组合数：3^9 = 19,683 组（可根据需要缩减搜索空间）。

### 3.2 网格生成

```python
import itertools

def generate_param_grid(grid: dict) -> list[dict]:
    keys = list(grid.keys())
    values = list(grid.values())
    combinations = list(itertools.product(*values))
    return [dict(zip(keys, combo)) for combo in combinations]
```

### 3.3 并行执行

使用 asyncio 并发执行多组参数回测，控制并发度避免数据库过载：

```python
import asyncio
from asyncio import Semaphore

async def run_grid_search(
    start_date: date,
    end_date: date,
    max_concurrency: int = 8,
) -> list[GridSearchResult]:
    param_combinations = generate_param_grid(PARAM_GRID)
    semaphore = Semaphore(max_concurrency)
    results = []

    async def run_one(params: dict) -> GridSearchResult:
        async with semaphore:
            async with async_session_factory() as session:
                signals = await run_backtest(session, params, start_date, end_date)
                metrics = evaluate_signals(signals)
                return GridSearchResult(params=params, metrics=metrics)

    tasks = [run_one(p) for p in param_combinations]
    results = await asyncio.gather(*tasks, return_exceptions=True)

    # 过滤异常，只保留成功结果
    return [r for r in results if isinstance(r, GridSearchResult)]
```

### 3.4 结果排序

默认按综合得分排序（可配置权重）：

```python
def rank_results(results: list[GridSearchResult]) -> list[GridSearchResult]:
    """综合得分 = 胜率(5d) * 0.4 + 盈亏比 * 0.3 + 夏普比率 * 0.3"""
    for r in results:
        m = r.metrics
        r.score = (
            (m.win_rate_5d or 0) * 0.4 +
            min(m.profit_loss_ratio or 0, 5) / 5 * 0.3 +  # 盈亏比上限 5
            min(m.sharpe_ratio or 0, 3) / 3 * 0.3          # 夏普上限 3
        )
    return sorted(results, key=lambda r: r.score, reverse=True)
```

---

## 4. 策略评估指标

### 4.1 指标定义

```python
@dataclass
class BacktestMetrics:
    # 信号统计
    total_signals: int          # 总信号数
    signals_per_month: float    # 每月平均信号数

    # 胜率（正收益比例）
    win_rate_1d: float          # 1日胜率
    win_rate_3d: float          # 3日胜率
    win_rate_5d: float          # 5日胜率
    win_rate_10d: float         # 10日胜率

    # 收益统计
    avg_ret_1d: float           # 1日平均收益率
    avg_ret_3d: float           # 3日平均收益率
    avg_ret_5d: float           # 5日平均收益率
    avg_ret_10d: float          # 10日平均收益率

    # 盈亏比（平均盈利 / 平均亏损的绝对值）
    profit_loss_ratio: float    # 基于 5d 收益计算

    # 风险指标
    max_drawdown: float         # 最大回撤（基于 10d 收益序列）
    sharpe_ratio: float         # 夏普比率（年化，无风险利率 3%）
```

### 4.2 计算方法

```python
def evaluate_signals(signals: list[BacktestSignal]) -> BacktestMetrics:
    if not signals:
        return BacktestMetrics(total_signals=0, ...)

    rets_5d = [s.ret_5d for s in signals if s.ret_5d is not None]
    rets_10d = [s.ret_10d for s in signals if s.ret_10d is not None]

    wins_5d = [r for r in rets_5d if r > 0]
    losses_5d = [r for r in rets_5d if r < 0]

    # 盈亏比
    avg_win = sum(wins_5d) / len(wins_5d) if wins_5d else 0
    avg_loss = abs(sum(losses_5d) / len(losses_5d)) if losses_5d else 1
    profit_loss_ratio = avg_win / avg_loss if avg_loss > 0 else 0

    # 最大回撤（基于 10d 收益序列，按信号日期排序）
    cumulative = 0.0
    peak = 0.0
    max_dd = 0.0
    for r in rets_10d:
        cumulative += r
        peak = max(peak, cumulative)
        max_dd = max(max_dd, peak - cumulative)

    # 夏普比率（年化）
    import statistics
    if len(rets_5d) > 1:
        mean_ret = statistics.mean(rets_5d)
        std_ret = statistics.stdev(rets_5d)
        # 假设每周约 1 个信号，年化约 50 个
        annual_factor = (50 ** 0.5)
        risk_free = 0.03 / 50
        sharpe = (mean_ret - risk_free) / std_ret * annual_factor if std_ret > 0 else 0
    else:
        sharpe = 0

    # 信号频率
    if signals:
        date_range_days = (signals[-1].signal_date - signals[0].signal_date).days
        months = max(date_range_days / 30, 1)
        signals_per_month = len(signals) / months
    else:
        signals_per_month = 0

    return BacktestMetrics(
        total_signals=len(signals),
        signals_per_month=round(signals_per_month, 1),
        win_rate_1d=_win_rate(signals, "ret_1d"),
        win_rate_3d=_win_rate(signals, "ret_3d"),
        win_rate_5d=_win_rate(signals, "ret_5d"),
        win_rate_10d=_win_rate(signals, "ret_10d"),
        avg_ret_1d=_avg_ret(signals, "ret_1d"),
        avg_ret_3d=_avg_ret(signals, "ret_3d"),
        avg_ret_5d=_avg_ret(signals, "ret_5d"),
        avg_ret_10d=_avg_ret(signals, "ret_10d"),
        profit_loss_ratio=round(profit_loss_ratio, 2),
        max_drawdown=round(max_dd, 4),
        sharpe_ratio=round(sharpe, 2),
    )
```

---

## 5. 回测报告输出

### 5.1 参数组合排名表

```
排名  accumulation_days  min_t0_pct_chg  min_t0_vol_ratio  ...  胜率(5d)  盈亏比  夏普  综合得分
1     60                 6.0             2.5               ...  62.3%     2.1     1.8   0.74
2     45                 6.0             3.0               ...  60.1%     2.3     1.6   0.72
3     60                 7.0             2.5               ...  61.5%     1.9     1.7   0.71
...
```

### 5.2 最优参数推荐

回测完成后，自动将 Top-1 参数写入推荐结果，并附上置信度说明：

```json
{
  "recommended_params": {
    "accumulation_days": 60,
    "max_accumulation_range": 0.20,
    "min_t0_pct_chg": 6.0,
    "min_t0_vol_ratio": 2.5,
    "min_washout_days": 3,
    "max_washout_days": 8,
    "max_vol_shrink_ratio": 0.40,
    "max_tk_amplitude": 3.0,
    "ma_support_tolerance": 0.015
  },
  "metrics": {
    "total_signals": 312,
    "signals_per_month": 8.7,
    "win_rate_5d": 0.623,
    "profit_loss_ratio": 2.1,
    "max_drawdown": 0.082,
    "sharpe_ratio": 1.8
  },
  "backtest_period": "2024-01-01 ~ 2025-12-31",
  "rank": 1,
  "score": 0.74
}
```

### 5.3 收益曲线（可选）

回测结果中保存每个信号的日期和收益，前端可按需绘制累计收益曲线：

```sql
-- 查询某次回测的信号序列（用于前端绘图）
SELECT signal_date, ret_5d, cumulative_ret
FROM backtest_results
WHERE run_id = :run_id
ORDER BY signal_date
```

---

## 6. 数据库表设计

### 6.1 回测结果表

```sql
CREATE TABLE backtest_results (
    id SERIAL PRIMARY KEY,
    run_id UUID NOT NULL DEFAULT gen_random_uuid(),  -- 每次回测的唯一 ID
    strategy_name VARCHAR(64) NOT NULL DEFAULT 'volume-price-pattern',
    params JSONB NOT NULL,                           -- 本次回测使用的参数
    backtest_start DATE NOT NULL,                    -- 回测起始日期
    backtest_end DATE NOT NULL,                      -- 回测结束日期

    -- 评估指标
    total_signals INT,
    signals_per_month NUMERIC(8,2),
    win_rate_1d NUMERIC(6,4),
    win_rate_3d NUMERIC(6,4),
    win_rate_5d NUMERIC(6,4),
    win_rate_10d NUMERIC(6,4),
    avg_ret_1d NUMERIC(8,4),
    avg_ret_3d NUMERIC(8,4),
    avg_ret_5d NUMERIC(8,4),
    avg_ret_10d NUMERIC(8,4),
    profit_loss_ratio NUMERIC(8,4),
    max_drawdown NUMERIC(8,4),
    sharpe_ratio NUMERIC(8,4),
    composite_score NUMERIC(8,4),                   -- 综合得分

    -- 信号明细（JSONB 存储，避免过多表）
    signals JSONB,                                   -- [{ts_code, signal_date, ret_1d, ...}]

    -- 元数据
    is_grid_search BOOLEAN DEFAULT FALSE,            -- 是否为网格搜索的一部分
    grid_search_id UUID,                             -- 关联的网格搜索批次
    rank_in_grid INT,                                -- 在网格搜索中的排名
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_backtest_run_id ON backtest_results(run_id);
CREATE INDEX idx_backtest_grid_id ON backtest_results(grid_search_id);
CREATE INDEX idx_backtest_score ON backtest_results(composite_score DESC);
CREATE INDEX idx_backtest_strategy ON backtest_results(strategy_name, created_at DESC);
```

---

## 7. 技术实现

### 7.1 模块结构

```
app/backtest/
├── __init__.py
├── engine.py          # 回测引擎主体（逐日模拟）
├── evaluator.py       # 评估指标计算
├── grid_search.py     # 参数网格搜索
├── models.py          # 数据模型（BacktestSignal, BacktestMetrics, GridSearchResult）
├── queries.py         # SQL 查询语句
└── router.py          # FastAPI 路由
```

### 7.2 API 接口

#### POST /backtest/run — 启动单次回测

```python
@router.post("/backtest/run")
async def run_backtest_api(req: BacktestRequest):
    """
    启动一次回测（异步执行，立即返回 run_id）。
    """
    run_id = str(uuid4())
    # 后台异步执行，不阻塞请求
    asyncio.create_task(_run_and_save(run_id, req))
    return {"run_id": run_id, "status": "running"}
```

请求体：

```json
{
  "start_date": "2024-01-01",
  "end_date": "2025-12-31",
  "params": {
    "accumulation_days": 60,
    "max_accumulation_range": 0.20,
    "min_t0_pct_chg": 6.0,
    "min_t0_vol_ratio": 2.5,
    "min_washout_days": 3,
    "max_washout_days": 8,
    "max_vol_shrink_ratio": 0.40,
    "max_tk_amplitude": 3.0,
    "ma_support_tolerance": 0.015
  }
}
```

#### POST /backtest/grid-search — 启动网格搜索

```json
{
  "start_date": "2024-01-01",
  "end_date": "2025-12-31",
  "param_grid": {
    "accumulation_days": [30, 45, 60],
    "min_t0_pct_chg": [5.0, 6.0, 7.0],
    "min_t0_vol_ratio": [2.0, 2.5, 3.0]
  },
  "max_concurrency": 8
}
```

#### GET /backtest/results — 查询回测结果

```
GET /backtest/results?run_id=<uuid>
GET /backtest/results?grid_search_id=<uuid>&limit=20&order_by=composite_score
```

响应示例：

```json
{
  "results": [
    {
      "run_id": "...",
      "params": {...},
      "metrics": {
        "total_signals": 312,
        "win_rate_5d": 0.623,
        "profit_loss_ratio": 2.1,
        "sharpe_ratio": 1.8,
        "max_drawdown": 0.082
      },
      "rank_in_grid": 1,
      "composite_score": 0.74
    }
  ],
  "total": 243
}
```

### 7.3 与现有系统的集成

- 回测模块独立于策略执行模块，不影响生产 Pipeline
- 复用 `async_session_factory` 和现有数据库连接池
- 回测时读取的是历史数据，不写入 `strategy_watchpool`（使用内存模拟池）
- 网格搜索结果可通过 API 查询，前端展示排名表和最优参数

---

## 8. 性能预估

| 操作 | 预估耗时 | 说明 |
|------|---------|------|
| 单次回测（1年数据） | 30~60s | 约 250 个交易日，每日全市场扫描 |
| 网格搜索（243组 × 1年） | 10~20min | 并发度 8，约 30 批次 |
| 收益计算（SQL 批量） | <5s | 一次 SQL 查询所有信号的后续价格 |
| 结果写入 DB | <1s | JSONB 存储，单条 INSERT |

**注意：** 网格搜索建议在非交易时段（夜间）执行，避免与生产 Pipeline 竞争数据库连接。
