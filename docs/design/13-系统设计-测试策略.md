# 系统设计 - 测试策略

> **版本：** v1.0
> **日期：** 2026-02-07
> **关联任务：** Task C4
> **状态：** Final
> **前置依赖：** 所有详细设计文档
>
> **V1 实施范围：** V1 只写核心策略的单元测试和关键链路的集成测试，去掉 CI/CD 集成和覆盖率强制要求。

---

## 1. 模块概述

### 1.1 职责

定义系统的测试分层、Mock 策略和关键测试用例，确保核心功能的正确性。

### 1.2 V1 测试原则

- **只测核心链路：** 数据采集 → ETL → 技术指标 → 策略筛选 → 回测
- **只测容易出错的：** 复权计算、涨跌停判断、策略信号逻辑
- **不追求覆盖率：** 不设硬性覆盖率指标，优先保证关键路径正确
- **手动运行：** `pytest` 命令行执行，不配置 CI

---

## 2. 测试分层

### 2.1 V1 测试层级

| 层级 | 范围 | 工具 | V1 要求 |
|:---|:---|:---|:---|
| **单元测试** | 策略逻辑、复权计算、涨跌停判断、指标计算 | pytest | 每种 V1 策略至少 1 个用例 |
| **集成测试** | 数据采集 → ETL → 策略执行 端到端 | pytest + 真实 DB | 核心链路 1 个完整用例 |
| **API 测试** | HTTP 接口契约验证 | pytest + httpx | 核心接口（strategy/run, backtest/run） |

### 2.2 V2 再加

| 层级 | 说明 | 推迟原因 |
|:---|:---|:---|
| CI 集成 | GitHub Actions 自动运行 | V1 手动运行足够 |
| 覆盖率报告 | pytest-cov 生成 | V1 不追求覆盖率 |
| 性能测试 | 策略管道执行时间基准 | V1 先跑通再优化 |

---

## 3. Mock 策略

### 3.1 数据源 Mock

预录制真实 API 返回数据，存为 JSON fixture，测试时不依赖外部网络。

```
tests/
├── fixtures/
│   ├── baostock_daily_600519.json    # BaoStock 日线样本
│   ├── akshare_daily_600519.json     # AKShare 日线样本
│   ├── finance_indicator_600519.json # 财务指标样本
│   └── stock_list_sample.json        # 股票列表样本（50 只）
```

```python
import json
from pathlib import Path
from unittest.mock import AsyncMock

import pytest


@pytest.fixture
def mock_baostock_daily() -> list[dict]:
    """加载 BaoStock 日线 fixture"""
    path = Path(__file__).parent / "fixtures" / "baostock_daily_600519.json"
    return json.loads(path.read_text())


@pytest.fixture
def mock_data_source(mock_baostock_daily):
    """Mock 数据源客户端"""
    client = AsyncMock()
    client.fetch_daily.return_value = mock_baostock_daily
    client.health_check.return_value = True
    return client
```

### 3.2 AI 模型 Mock

```python
@pytest.fixture
def mock_ai_response() -> dict:
    """固定的 AI 分析返回结果"""
    return {
        "sentiment_score": 75,
        "summary": "业绩稳健，估值合理",
        "event_type": "业绩",
        "impact_duration": "中期",
    }


@pytest.fixture
def mock_gemini_client(mock_ai_response):
    """Mock Gemini 客户端"""
    client = AsyncMock()
    client.chat.return_value = json.dumps(mock_ai_response)
    client.get_last_usage.return_value = {"input": 500, "output": 100}
    return client
```

### 3.3 Redis Mock

```python
import fakeredis.aioredis

@pytest.fixture
async def mock_redis():
    """使用 fakeredis 替代真实 Redis"""
    redis = fakeredis.aioredis.FakeRedis()
    yield redis
    await redis.flushall()
    await redis.close()
```

---

## 4. 核心测试用例

### 4.1 复权计算测试

```python
import pandas as pd
from app.data.adj import calc_forward_adj


class TestForwardAdj:
    """前复权计算测试"""

    def test_basic_forward_adj(self) -> None:
        """基本前复权：adj_price = raw_price * (adj_factor / latest_factor)"""
        df = pd.DataFrame({
            "open": [10.0, 10.0, 20.0],
            "high": [11.0, 11.0, 22.0],
            "low": [9.0, 9.0, 18.0],
            "close": [10.5, 10.5, 21.0],
            "adj_factor": [1.0, 1.0, 2.0],  # 第 3 天发生了 10 送 10
        })
        result = calc_forward_adj(df)
        # 最新 factor=2.0，历史 factor=1.0
        # 历史价格应乘以 1.0/2.0 = 0.5
        assert result["close"].iloc[0] == 5.25  # 10.5 * 0.5
        assert result["close"].iloc[2] == 21.0  # 21.0 * 1.0（最新不变）

    def test_no_adj_factor(self) -> None:
        """无复权因子时返回原始数据"""
        df = pd.DataFrame({"open": [10.0], "close": [10.5]})
        result = calc_forward_adj(df)
        assert result["close"].iloc[0] == 10.5

    def test_empty_dataframe(self) -> None:
        """空 DataFrame 不报错"""
        df = pd.DataFrame(columns=["open", "close", "adj_factor"])
        result = calc_forward_adj(df)
        assert result.empty
```

### 4.2 涨跌停判断测试

```python
from app.backtest.price_limit import calc_price_limit, is_limit_up, is_limit_down


class TestPriceLimit:
    """涨跌停判断测试"""

    def test_main_board_10pct(self) -> None:
        """主板 ±10%"""
        up, down = calc_price_limit(10.00, "600519.SH")
        assert up == 11.00
        assert down == 9.00

    def test_gem_board_20pct(self) -> None:
        """创业板 ±20%"""
        up, down = calc_price_limit(50.00, "300001.SZ")
        assert up == 60.00
        assert down == 40.00

    def test_st_5pct(self) -> None:
        """ST 股 ±5%"""
        up, down = calc_price_limit(5.00, "000001.SZ", is_st=True)
        assert up == 5.25
        assert down == 4.75

    def test_rounding(self) -> None:
        """四舍五入到分"""
        up, down = calc_price_limit(13.57, "600000.SH")
        assert up == 14.93   # 13.57 * 1.10 = 14.927 → 14.93
        assert down == 12.21  # 13.57 * 0.90 = 12.213 → 12.21

    def test_limit_up_detection(self) -> None:
        """涨停检测"""
        assert is_limit_up(11.00, 10.00, "600519.SH") is True
        assert is_limit_up(10.99, 10.00, "600519.SH") is False
```

### 4.3 策略信号测试

```python
import pandas as pd
from app.strategy.technical import MACrossStrategy


class TestMACrossStrategy:
    """均线金叉策略测试"""

    def test_golden_cross_signal(self) -> None:
        """MA5 上穿 MA10 应产生买入信号"""
        # 构造数据：前 10 天 MA5 < MA10，第 11 天 MA5 > MA10
        prices = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 12, 13]
        df = pd.DataFrame({
            "close": prices,
            "trade_date": pd.date_range("2026-01-01", periods=12),
            "ts_code": ["600519.SH"] * 12,
        })
        strategy = MACrossStrategy(params={"fast": 5, "slow": 10})
        signals = strategy.filter_batch(df)
        # 最后一行应该有信号（MA5 因为近期涨价而上穿 MA10）
        assert signals.iloc[-1] is True

    def test_no_signal_when_downtrend(self) -> None:
        """下跌趋势中不应产生金叉信号"""
        prices = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9]
        df = pd.DataFrame({
            "close": prices,
            "trade_date": pd.date_range("2026-01-01", periods=12),
            "ts_code": ["600519.SH"] * 12,
        })
        strategy = MACrossStrategy(params={"fast": 5, "slow": 10})
        signals = strategy.filter_batch(df)
        assert signals.iloc[-1] is False

    def test_insufficient_data(self) -> None:
        """数据不足时不产生信号"""
        df = pd.DataFrame({
            "close": [10, 11, 12],
            "trade_date": pd.date_range("2026-01-01", periods=3),
            "ts_code": ["600519.SH"] * 3,
        })
        strategy = MACrossStrategy(params={"fast": 5, "slow": 10})
        signals = strategy.filter_batch(df)
        # 数据不足 10 天，无法计算 MA10，全部为 False
        assert not signals.any()
```

### 4.4 回测引擎集成测试

```python
import backtrader as bt
import pandas as pd
import pytest
from datetime import date

from app.backtest.engine import configure_cerebro
from app.backtest.strategy import AStockStrategy
from app.backtest.price_limit import calc_price_limit


class SimpleTestStrategy(AStockStrategy):
    """测试用简单策略：第 5 天买入，第 15 天卖出"""
    def next_strategy(self) -> None:
        if len(self) == 5 and not self.position:
            self.buy(size=100)
        elif len(self) == 15 and self.position:
            self.close()


class TestBacktestEngine:
    """回测引擎集成测试"""

    def test_basic_backtest_runs(self) -> None:
        """基本回测能正常运行并产生结果"""
        # 构造 20 天的测试数据
        dates = pd.date_range("2026-01-01", periods=20, freq="B")
        df = pd.DataFrame({
            "open": [100 + i * 0.5 for i in range(20)],
            "high": [101 + i * 0.5 for i in range(20)],
            "low": [99 + i * 0.5 for i in range(20)],
            "close": [100 + i * 0.5 for i in range(20)],
            "volume": [10000] * 20,
        }, index=dates)

        cerebro = bt.Cerebro()
        cerebro.adddata(bt.feeds.PandasData(dataname=df))
        cerebro.addstrategy(SimpleTestStrategy, enable_price_limit=False)
        cerebro.broker.setcash(100000)

        results = cerebro.run()
        strat = results[0]

        # 应该有交易记录
        assert len(strat.trade_log) > 0
        # 最终资金应该不等于初始资金（有交易发生）
        assert strat.broker.getvalue() != 100000

    def test_commission_deducted(self) -> None:
        """交易成本应被正确扣除"""
        dates = pd.date_range("2026-01-01", periods=20, freq="B")
        df = pd.DataFrame({
            "open": [100] * 20,
            "high": [100] * 20,
            "low": [100] * 20,
            "close": [100] * 20,  # 价格不变
            "volume": [10000] * 20,
        }, index=dates)

        cerebro = bt.Cerebro()
        cerebro.adddata(bt.feeds.PandasData(dataname=df))
        cerebro.addstrategy(SimpleTestStrategy, enable_price_limit=False)
        cerebro.broker.setcash(100000)
        # 设置佣金
        cerebro.broker.setcommission(commission=0.001)

        results = cerebro.run()
        # 价格不变但有交易，最终资金应小于初始（佣金扣除）
        assert results[0].broker.getvalue() < 100000
```

### 4.5 API 接口测试

```python
import pytest
from httpx import AsyncClient
from app.main import app


@pytest.fixture
async def client():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac


class TestStrategyAPI:
    """策略 API 测试"""

    @pytest.mark.asyncio
    async def test_run_strategy(self, client: AsyncClient) -> None:
        """POST /api/v1/strategy/run 应返回 task_id"""
        resp = await client.post("/api/v1/strategy/run", json={
            "base_filter": {"exclude_st": True, "exclude_halt": True},
            "strategies": [
                {"id": "tech_ma_cross", "params": {"fast": 5, "slow": 10}, "enabled": True}
            ],
            "ai_filter": {"enabled": False},
        })
        assert resp.status_code == 200
        data = resp.json()
        assert "task_id" in data
        assert data["status"] == "pending"

    @pytest.mark.asyncio
    async def test_invalid_strategy_params(self, client: AsyncClient) -> None:
        """无效参数应返回 422"""
        resp = await client.post("/api/v1/strategy/run", json={
            "strategies": [],  # 空策略列表
        })
        assert resp.status_code == 422


class TestBacktestAPI:
    """回测 API 测试"""

    @pytest.mark.asyncio
    async def test_submit_backtest(self, client: AsyncClient) -> None:
        """POST /api/v1/backtest/run 应返回 task_id"""
        resp = await client.post("/api/v1/backtest/run", json={
            "strategy_id": 1,
            "start_date": "2024-01-01",
            "end_date": "2025-12-31",
            "initial_capital": 100000,
        })
        assert resp.status_code == 200
        data = resp.json()
        assert "task_id" in data

    @pytest.mark.asyncio
    async def test_invalid_date_range(self, client: AsyncClient) -> None:
        """结束日期早于开始日期应返回错误"""
        resp = await client.post("/api/v1/backtest/run", json={
            "strategy_id": 1,
            "start_date": "2025-12-31",
            "end_date": "2024-01-01",
            "initial_capital": 100000,
        })
        assert resp.status_code == 422
```

---

## 5. 测试数据管理

### 5.1 Fixture 文件规范

| 文件 | 内容 | 数据量 | 来源 |
|:---|:---|:---|:---|
| `baostock_daily_600519.json` | 贵州茅台 2024 年日线 | ~250 行 | BaoStock 真实数据录制 |
| `akshare_daily_600519.json` | 同上，AKShare 格式 | ~250 行 | AKShare 真实数据录制 |
| `finance_indicator_600519.json` | 贵州茅台近 4 个季度财务指标 | 4 行 | Tushare 真实数据录制 |
| `stock_list_sample.json` | 50 只代表性股票基础信息 | 50 行 | 手动挑选 |

### 5.2 录制脚本

```python
"""
录制测试 fixture 数据。
运行一次即可，结果保存为 JSON 文件供测试使用。

用法: python scripts/record_fixtures.py
"""
import json
from pathlib import Path

from app.data.sources import BaoStockClient

FIXTURE_DIR = Path("tests/fixtures")


async def record_baostock_daily():
    client = BaoStockClient()
    await client.login()
    data = await client.fetch_daily("600519.SH", "2024-01-01", "2024-12-31")
    await client.logout()
    FIXTURE_DIR.mkdir(exist_ok=True)
    (FIXTURE_DIR / "baostock_daily_600519.json").write_text(
        json.dumps(data, ensure_ascii=False, indent=2)
    )
    print(f"录制完成: {len(data)} 行")
```

---

## 6. 运行方式

```bash
# 运行所有测试
pytest tests/ -v

# 只运行单元测试
pytest tests/unit/ -v

# 只运行集成测试（需要数据库）
pytest tests/integration/ -v

# 只运行 API 测试
pytest tests/api/ -v

# 运行特定测试文件
pytest tests/unit/test_price_limit.py -v

# 显示详细输出（调试用）
pytest tests/ -v -s --tb=long
```
